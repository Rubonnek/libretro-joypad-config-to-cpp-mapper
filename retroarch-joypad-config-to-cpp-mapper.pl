#!/usr/bin/perl

# Copyright (C) 2017 - Wilson E. Alvarez
#
# You should have received a copy of the GNU General Public License along with this parser.
# If not, see <http://www.gnu.org/licenses/>.

# Important: The resulting C++ code and files generated by this tool are *NOT* covered by
# the GPL v3.  These resulting files are considered to be generated under
# normal use of this tool, and the they are released to the public
# domain. They property of the developer who uses this mapping tool.

use strict;
use warnings;
use utf8;
#use diagnostics;
use POSIX;
use Getopt::Long;
use XML::Parser;
use Data::Dumper;

# We need to print some utf8 characters.
#binmode STDOUT, ':utf8';

# Envrionment variables:
my $input_filename;
#my $output_filename;
my $declare_cpp_variables;
my $help;

#"output-file|o=s"   => \$output_filename,
GetOptions ("input-file|i=s"   => \$input_filename,
	"declare-cpp-variables|d"   => \$declare_cpp_variables,
	"help|h"  => \$help)
	or die $!;

sub usage {
	print << "	EOF"
	Description:
	parser for converting the controller information from the libretro project to C++ std::map

	Usage:
	-i, --input-filename <filename>			Input file.

	$0 --input-file foo.cpp

	EOF

}

if ( defined $help )
{
	usage();
	exit;
}

if ( ! defined $input_filename )
{
	print STDERR "Error: Input file ( -i ) must be given.";
	usage();
	exit;
}

#if ( ! defined $output_filename )
#{
#	print STDERR "Error: Input file ( -i ) must be given.";
#	usage();
#	exit;
#}



# Loop over the contents of the file:
open my $input_filehandle, "<", $input_filename or die $!;

# Note: the RetroArch mapping consists of maping all the controllers to a
# theoretical SNES controller with thumbsticks and extra shoulder buttons This
# is the mapping we are doing between the libretro configuration to the
# cocos2d-x configuration.  For the cocos2d-x we will use a theoretical Xbox
# controller since most mobile controllers also use that same mapping.

# input_a_btn                  ->                 Controller::Key::BUTTON_B                     
# input_b_btn                  ->                 Controller::Key::BUTTON_A                     
# input_down_btn               ->                 Controller::Key::BUTTON_DPAD_DOWN             
# input_l2_axis                ->                 Controller::Key::AXIS_LEFT_TRIGGER            
# input_l3_btn                 ->                 Controller::Key::BUTTON_LEFT_THUMBSTICK       
# input_l_btn                  ->                 Controller::Key::BUTTON_LEFT_SHOULDER         
# input_l_x_minus_axis         ->                 Controller::Key::JOYSTICK_LEFT_X              
# input_l_y_minus_axis         ->                 Controller::Key::JOYSTICK_LEFT_Y              
# input_left_btn               ->                 Controller::Key::BUTTON_DPAD_LEFT             
# input_r2_axis                ->                 Controller::Key::AXIS_RIGHT_TRIGGER           
# input_r3_btn                 ->                 Controller::Key::BUTTON_RIGHT_THUMBSTICK      
# input_r_btn                  ->                 Controller::Key::BUTTON_RIGHT_SHOULDER        
# input_r_x_minus_axis         ->                 Controller::Key::JOYSTICK_RIGHT_X             
# input_r_y_minus_axis         ->                 Controller::Key::JOYSTICK_RIGHT_Y             
# input_right_btn              ->                 Controller::Key::BUTTON_DPAD_RIGHT            
# input_select_btn             ->                 Controller::Key::BUTTON_SELECT                
# input_start_btn              ->                 Controller::Key::BUTTON_START                 
# input_up_btn                 ->                 Controller::Key::BUTTON_DPAD_UP               
# input_x_btn                  ->                 Controller::Key::BUTTON_Y                     
# input_y_btn                  ->                 Controller::Key::BUTTON_X                     

# Note: the XBOX button on the Xbox 360 controller is mapped into
# "input_menu_toggle_btn" in RetroArch. The problem is RetroArch sometimes uses
# combinations of two of any of the above buttons for triggering RetroArch's menu.  It
# is, therefore, impossible to do a 1-1 conversion from the libretro since we cannot provide those mappings in cocos2d-x.
# configuration to the cocos2d-x configuration

# The udev device name will also need to be used in order to attach an input profile with each device
# input_device = "Xbox 360 Wireless Receiver"


# For buttons, we are going to use an std::map. Here is how we are going to control each profile:
#	std::map<std::string deviceName, std::pair(std::unordered_map<int, int>, std::unordered_map<int,int>) > s_controllerProfiles;

# Here's how we are going to store each controller profile:
# We get the input_device from the retroarch configuration files and store it as:
#	std::string deviceName = (what we get from input_device);
#	std::vector buttonInputMap;
#	buttonInputMap[(what we get from parsing the retroarch config)] = Controller::Key::Correspondingkey;
#	buttonInputMap[(what we get from parsing the retroarch config)] = Controller::Key::Correspondingkey;
#	buttonInputMap[(what we get from parsing the retroarch config)] = Controller::Key::Correspondingkey;
#	... and so on
#	std::vector axisInputMap;
#	axisInputMap[(what we get from parsing the retroarch config)] = Controller::Key::Correspondingkey;
#	axisInputMap[(what we get from parsing the retroarch config)] = Controller::Key::Correspondingkey;
#	axisInputMap[(what we get from parsing the retroarch config)] = Controller::Key::Correspondingkey;
#	... and so on

# And when we are done parsing the configuration file, we push it back to the std::map
#	s_controllerProfiles.insert(std::make_pair(deviceName, input_mapping));

# Here's how we are going to match each controller profile when a controller gets connected:

#	std::string name = glfwGetJoystickName(int);
#	for (const auto& controller_profile x : controller_profiles)
#	{
#		if ( name.find(controller_profile.first) )
#		{
#			_controller_profile =  controller_profile.second;
#			CCLOG("Found controller name is: %s", name.c_str());
#			CCLOG("Found controller profile named: %s", controller_profile.first);
#			CCLOG("Applying button mapping and axis mapping to raw input..");
#			break;
#		}
#	}

my %button_mapping_to_import = (
	input_a_btn => 'Controller::Key::BUTTON_B',
	input_b_btn => 'Controller::Key::BUTTON_A',
	input_down_btn => 'Controller::Key::BUTTON_DPAD_DOWN',
	input_l3_btn => 'Controller::Key::BUTTON_LEFT_THUMBSTICK',
	input_l_btn => 'Controller::Key::BUTTON_LEFT_SHOULDER',
	input_left_btn => 'Controller::Key::BUTTON_DPAD_LEFT',
	input_r3_btn => 'Controller::Key::BUTTON_RIGHT_THUMBSTICK',
	input_r_btn => 'Controller::Key::BUTTON_RIGHT_SHOULDER',
	input_right_btn => 'Controller::Key::BUTTON_DPAD_RIGHT',
	input_select_btn => 'Controller::Key::BUTTON_SELECT',
	input_start_btn => 'Controller::Key::BUTTON_START',
	input_up_btn => 'Controller::Key::BUTTON_DPAD_UP',
	input_x_btn => 'Controller::Key::BUTTON_Y',
	input_y_btn => 'Controller::Key::BUTTON_X',
);

my %axis_mapping_to_import = (
	input_l2_axis => 'Controller::Key::AXIS_LEFT_TRIGGER',
	input_l_x_minus_axis => 'Controller::Key::JOYSTICK_LEFT_X',
	input_l_y_minus_axis => 'Controller::Key::JOYSTICK_LEFT_Y',
	input_r2_axis => 'Controller::Key::AXIS_RIGHT_TRIGGER',
	input_r_x_minus_axis => 'Controller::Key::JOYSTICK_RIGHT_X',
	input_r_y_minus_axis => 'Controller::Key::JOYSTICK_RIGHT_Y',

	# On controllers that have the DPAD as an axis, the libretro config has them
	# defined with the _up_ _left_ _right_ and _down_ keywords We only need two
	# for our purposes. glfw does the rest when pulling out the axis data
	input_up_axis => 'Controller::Key::BUTTON_DPAD_UP',
	input_left_axis => 'Controller::Key::BUTTON_DPAD_LEFT',
	input_right_axis => 'Controller::Key::BUTTON_DPAD_RIGHT',
	input_down_axis => 'Controller::Key::BUTTON_DPAD_DOWN',
);

my $deviceName;
my $button_input_mapping_in_cpp;
my $axis_input_mapping_in_cpp;

# Generate final filename:
use File::Basename;
my $output_filename = $input_filename;
$output_filename = "./in_cpp/" . basename($output_filename) . ".cpp";
open my $output_filehandle, ">", $output_filename or die $!;

# Loop over the input filename lines:
my %hash_to_count_how_many_times_a_key_has_been_processed;
while( <$input_filehandle> )
{

	# Check if we found the device name
	if ( $_ =~ /^\s*input_device\s*=\s*"(.*)"/ )
	{
		#Debug:
		#print "Found device name: " . $1;

		# Text to construct:
		#	std::string deviceName = (what we get from input_device);
		#	std::vector buttonInputMap;

		if ( defined $declare_cpp_variables )
		{

			$deviceName .= "// Create the necessary variables:\n";
			$deviceName .= "std::string deviceName = \"" . $1 . "\";\n";
			$deviceName .= "std::unordered_map<int,int> buttonInputMap;\n";
			$deviceName .= "std::unordered_map<int,int> axisInputMap;\n";
			$deviceName .= "// Make sure the following is a member variable, or create it now:\n";
			$deviceName .= "// std::map<std::string, std::pair< std::unordered_map<int, int>, std::unordered_map<int,int> > > s_controllerProfiles;";
		}
		else
		{
			$deviceName .= "// Prepare variables:\n";
			$deviceName .= "deviceName = \"" . $1 . "\";\n";
			$deviceName .= "buttonInputMap.clear();\n";
			$deviceName .= "axisInputMap.clear();\n";
		}
		$deviceName .= "\n\n// Map the controller inputs to Controller::Key codes\n";
	}

	# Loop for mapping the buttons ( state is an int or bool ):
	foreach my $key_to_import ( keys %button_mapping_to_import )
	{
		#print $key_to_import . "\n";
		if ( $_ =~ /^\s*\Q$key_to_import\E\s*=\s*"(\+*\-*\d*)"/ )
		{
			# Debug Regular expression:
			# print "Line is: " . $_;
			# print "value found is: " . $1 . "\n";

			# Remove any noise from the value.
			# Note: We are keeping the +, - noise in
			# case we have to update this code later on when GLFW 3.3 is stable
			# and released

			my $key_code = $1;
			$key_code =~ s/-//g;
			$key_code =~ s/\+//g;

			# Text to construct:
			#	buttonInputMap[(what we get from parsing the retroarch config)] = Controller::Key::Correspondingkey;
			#	... and so on

			if ( $key_code ne "" )
			{
				$button_input_mapping_in_cpp .= "buttonInputMap[" . $key_code . "] = " . $button_mapping_to_import{$key_to_import} . ";\n";
			}
		}
	}

	# Loop for mapping any of the axis on the controller:
	foreach my $key_to_import ( keys %axis_mapping_to_import )
	{
		#print $key_to_import . "\n";
		if ( $_ =~ /^\s*\Q$key_to_import\E\s*=\s*"(.*)"/ )
		{
			# Debug Regular expression:
			# print "Line is: " . $_;
			# print "value found is: " . $1 . "\n";

			# Remove any noise from the value.
			# Note: We are keeping the +, - noise in
			# case we have to update this code later on when GLFW 3.3 is stable
			# and released
			my $key_code = $1;
			$key_code =~ s/-//g;
			$key_code =~ s/\+//g;

			# For some joysticks, like the "Logitech Logitech Dual Action", the mapping has some word like h0down and such.
			# Turn this to numbers, and for the case of this Logitech controller, just map them to the right number:
			$key_code =~ s/h0down/5/g;
			$key_code =~ s/h0up/5/g;
			$key_code =~ s/h0left/4/g;
			$key_code =~ s/h0right/4/g;
			# For the controllers thatr contain the h0up, h0down, h0left, and h0right

			# Text to construct:
			#	axisInputMap[(what we get from parsing the retroarch config)] = Controller::Key::Correspondingkey;
			#	... and so on

			++$hash_to_count_how_many_times_a_key_has_been_processed{$key_code};

			if ( $key_code =~ /\d+/ && $hash_to_count_how_many_times_a_key_has_been_processed{$key_code} == 1)
			{
				$axis_input_mapping_in_cpp .= "axisInputMap[" . $key_code . "] = " . $axis_mapping_to_import{$key_to_import} . ";\n";
			}
			else # the key code has been processed more than once, print the linke but comment it to avoid cppcheck messages
			{
				$axis_input_mapping_in_cpp .= "//axisInputMap[" . $key_code . "] = " . $axis_mapping_to_import{$key_to_import} . ";\n";
			}
		}
	}
}

# Write cpp code to disk:

# Debug:
# print $deviceName;
# print $button_input_mapping_in_cpp;
# print $axis_input_mapping_in_cpp;
# print "\n// Add the controller profile to the mapping:\n";
# print "s_controllerProfiles.insert(std::make_pair(deviceName, std::make_pair(buttonInputMap, axisInputMap)));\n";

# Write to disk
print $output_filehandle $deviceName;
if ( defined $button_input_mapping_in_cpp )
{
	print $output_filehandle $button_input_mapping_in_cpp;
}
if ( defined $axis_input_mapping_in_cpp )
{
	print $output_filehandle $axis_input_mapping_in_cpp;
}
print $output_filehandle "\n\n// Add the controller profile to the map\n";
print $output_filehandle "s_controllerProfiles.insert(std::make_pair(deviceName, std::make_pair(buttonInputMap, axisInputMap)));\n";
print $output_filehandle "\n\n";
#print "\n\n\n" . $output_filename . "\n";

# Close up the filehandle:
close($output_filehandle);

